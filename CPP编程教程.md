# <font color = skyblue>CPP基础编程（C语言）</font>
### <font color = pink>Hello world</font>
main是一个程序的入口，每个程序都必须有一个。
```cpp
system("pause");
```
### <font color = pink>注释</font>
```cpp
// 单行注释	
/*多行注释*/
```
### <font color = pink>变量</font>
变量存在的意义：方便管理内存空间。
给一段内存空间取名，方便管理这段空间。

变量创建的语法：
```cpp
数据类型 变量名 = 变量初始值;
int a = 10;
```
### <font color = pink>常量</font>
宏常量，语法：
```cpp
#define 常量名 常量值
```
const修饰的变量：语法：
```cpp
const 数据类型 常变量名 = 常量值;
```
### <font color = pink>关键字：C++中预先保留的单词</font>
例如，整型int。不要用关键字给变量或者常量取名称。
### <font color = pink>标识符命名规则</font>
1、标识符不可以是关键字
2、只能包含字母数字下划线
3、第一个字符必须是字母或者下划线
4、标识符中的字母区分大小写

给变量起名的时候，最好能够做到见名知意。
### <font color = pink>数据类型</font>
C++ 规定在创建一个变量或者常量时。必须要指出相应的数据类型，否则无法给变量分配内存。
```cpp
short 短整型 2字节 16位 (-2^15~2^15-1)
int 整型 4字节
long 长整型 windows 4字节 Linux 4字节或8字节
long long 长长整型 8字节
```
数据类型存在的意义：给变量分配合适的空间。
### <font color = pink>关键字 sizeof</font>
利用 sizeof 可以统计数据类型所占的大小，语法：
```cpp
sizeof(数据类型/变量);
sizeof(int);
```
### <font color = pink>整型</font>
整数的意思。
### <font color = pink>浮点型（实型）</font>
```cpp
单精度 float 4字节 7位有效数字
双精度 double 8字节 15~16位有效数字
```
科学计数法
```cpp
float f2 = 3e2;     // 300		
float f2 = 3e-2;    // 0.03
```
cpp默认小数是双精度，3.14f这是单精度小数。
控制台默认显示6位有效数字。
### <font color = pink>字符型</font>
语法：
```cpp
char ch = 'a';
```
注意用单引号，不可以是双引号，单引号只能有一个字符，不可以是字符串。c和cpp中字符型只占1字节。
字符型变量内部存储的对应的ASCII码，用强制转换查看ASCII码：
```cpp
cout << (int)ch << endl;    // a - 97 A - 65
```
ASCII码：0-31控制字符，其余是显示字符。
### <font color = pink>转义字符（c语言用的比较多）</font>
作用：用于表示一些不能显示出来的ASCII字符。
```cpp
换行符 \n
反斜杠 \\
水平制表符号 \t
```
### <font color = pink>字符串型</font>
c语言风格字符串：
```cpp
char 变量名[] = "字符串值";     // []的作用是数组化，最后一位系统自己加\0
```
c++风格字符串：字符串变量 
```cpp
#include <string>
string 变量名 = "字符串值";	    // 注意包含一个头文件 #include <string>		
```
### <font color = pink>布尔类型 bool</font>
bool类型：占用1字节，非零的值都代表真，0代表假。
```cpp
bool flag = true;
```
### <font color = pink>数据的输入</font>
```cpp
cin >> 变量
int a = 0;
cin >> a; // >> 右运算符
```
### <font color = pink>运算符</font>
1、算数运算符
```cpp
除法：int n1 = 10; int n2 = 3; 则n1/n2 = 3，整数除法小数位会舍弃。
取模（取余）：10%3 = 1; 模3运算，只有整型可以取模运算，两个小数不能取模运算。

前置递增运算符 ++a	//先+1，再表达式运算
int a = 10;
int b = ++a * 10;		答案 110

后置递增运算符 a++	//先表达式运算，再让变量+1
int a = 10;
int b = a++ * 10;		答案 100
```
2、赋值运算符
```cpp
= 赋值
+= 加等于 a += 2; 等价于 a = a+2;
-= 减等于
*= 乘等于
/= 除等于
%= 模等于
```
3、比较运算符
```cpp
== 等于
!= 不等于
<
>
<=
>=
cout<< (a==b) <<endl;   // ()的作用是提高优先级
```
4、逻辑运算符
```cpp
!	非
&&	与	// 同真为真，其余为假
||	或
```
### <font color = pink>程序流程结构</font> 
1、顺序 2、选择 3、循环
### <font color = pink>选择</font>
单行 if 语句
```cpp
if(条件){条件满足执行的语句}
if条件语句后面加分号，则条件白写。
```
多行 if 语句
```cpp
if(条件){满足执行语句}else{条件不满足执行语句}
if(){}elseif(){}elseif(){}else{}
```
嵌套 if 语句

>练习 三只小猪称体重

三目运算符
```cpp
(条件1)?(条件2):(条件3);        // 1为真则执行条件2，1为假执行条件3
c = (a > b ? a:  b);           // 优点，比if结构简洁清晰
```
switch-case语句：switch的缺点，只能判断整型或者字符型，不能判断区间。
```cpp
switch(value)
{
	case = 结果1: 语句; break;  // break 是退出当前分支，不再执行
	default: 执行语句; break;
}
```
### <font color = pink>循环</font> 
while循环
>猜数字程序设计
```cpp
srand((unsigned int)time(NULL));    // srand 随机数种子 #include <ctime>
int num = rand() % 100;
```
do...while 语句

>练习：水仙花数，例如 1^3+5^3+3^3 = 153 每一位上的数字的立方之和等于本身，利用 do-while 语句，求出所有水仙花数。

for循环
```cpp 
for(起始表达式;条件表达式;末尾循环体){}
```
嵌套循环：循环计数变量冲突时候，采用就近原则。
>案例：乘法口诀表

跳转语句
```cpp
break 直接跳出循环 或 跳出 switch-case 语句
continue 跳出本次循环的后部分语句 执行下次循环
goto 标记
```
### <font color = pink>一维数组定义</font>
```cpp
int arr[len];
int arr[len] = {val1,val2,val3};
int arr[] = {val1,val2,val3};
```
特点：
放在一块连续的内存空间中，各个数据都是相同的数据类型。
数组从0开始索引，下标从0开始。我们可以通过下标访问数组中的元素。
数组赋值时没填满的部分会自动填0。
### <font color = pink>一维数组的名称</font>
统计整个数组在内存中的长度
```cpp
sizeof(arr)
```
可以获取数组在内存中的首地址
```cpp
int* p = &arr[1];
```
### <font color = pink>冒泡排序</font>
```cpp
#include <iostream>
using namespace std;
int main()
{
    //冒泡排序
    int line[] = {6,8,1,5,4,9,7,2,9};
    for(int i = 0;i < 9-1;i++)
    {
        for(int j = 0;j < 8-i;j++)
        {
            int t;
            if(line[j]>line[j+1])
            {
                t = line[j+1];
                line[j+1] = line[j];
                line[j] = t;
            }
        }
    }
    for(int i = 0;i < 9;i++)
    {
        cout<< line[i] <<" ";
    }
    cout << endl;
    return 0;
}
```
### <font color = pink>二维数组定义</font>
```cpp
int arr[row][col];
int arr[row][col] = {{v,v},{v,v}};
int arr[row][col] = {v,v,v,v};
int arr[][col] = {v,v,v,v};
```
### <font color = pink>二维数组的名称</font>
统计整个内存大小
```
1、查看整个矩阵的内存
2、查看某行的大小
3、查看某元素的大小
```
首地址
```
1、数组名称是首地址指针
```
### <font color = pink>字符串数组</font>
```cpp
string[] = {"张三","李四"};
```
### <font color = pink>函数</font>
作用：
1、将经常使用的代码封装起来，减少重复代码。
2、对于较大程序，一般分为若干程序块，每个模块实现特定功能。
### <font color = pink>函数的定义</font>
```
1、返回值类型	2、函数名	3、参数列表（形参列表）	4、函数体语句	5、return表达式
```
### <font color = pink>函数的调用</font>
语法：
```cpp
函数名(参数)
```
1、实际参数（实参）
2、形式参数（形参）
### <font color = pink>值传递</font>
1、所谓值传递，就是函数调用时，实参将参数值传给形式参数
2、值传递时候，如果形参变化，不会影响实参（函数体内对形参的任何操作都不会影响到外部的实参，例如交换函数，不会影响实参）
### <font color = pink>函数的常见样式</font>
无参无返 有参无返 无参有返 有参有返
### <font color = pink>函数的声明</font>
1、声明可以多次，定义只能一次。
2、可以提前告诉编译器函数的存在。
### <font color = pink>函数的分文件编写</font>
1、创建后缀名为.h的头文件
2、创建后缀名为.cpp的源文件
3、在头文件中写声明
4、在源文件中写定义
### <font color = pink>指针</font>
通过指针间接访问内存。指针变量保存的是另外一个变量的地址。
定义
```cpp
int* p = nullptr;
```
& 取地址符  * 取内容符
### <font color = pink>指针所占用的内存空间</font>
指针（无论什么类型int*，double*，float*），在32位系统（x86）中占用4字节。在64位系统（x64）中占用8字节。
### <font color = pink>空指针</font>
指向内存编号为0的空间
用途：初始化指针变量
注意：空指针的内存是不可以访问的,0~255之间的内存编号是系统使用的故不可以访问。
```cpp
int*p = NULL;
```
### <font color = pink>野指针</font>
指向非法的内存空间，空指针和野指针都不是我们自己申请的空间都不要随意去访问。
### <font color = pink>const修饰指针</font>
1、常量指针
* 指针的指向可以修改，但指针指向的内容不可以修改
```cpp
const int*p = &a;
```
2、指针常量
* 指针的指向不可以改，指针指向的值可以改。
```cpp
int* const p = &a;
```
3、双const
* 指针的指向不可以改，指针指向的值也不可以改。
```cpp
const int* const p = &a;
```
### <font color = pink>指针和数组</font>
```cpp
int*p = arr;	//arr就是数组首地址
p++ 就是下一个元素的地址
```
### <font color = pink>指针和函数</font>
1、值传递
2、地址传递
* 不想修改实参就用值传递，想修改实参就用地址传递
### <font color = pink>结构</font>
用户自定义数据类型
```cpp
struct st
{
    string name;
    int age;
};
```
定义
```cpp
//创建自定义变量 
st s1;
st s1 = {...};
```
定义结构体时，顺便创建一个结构体变量；
```cpp
struct st
{
    string name;
    int age;
}s1;
```
.成员运算符
```cpp
s1.name
```
### <font color = pink>结构体数组</font>
### <font color = pink>结构体指针</font>
1、创建自定义结构变量
2、通过指针指向结构体变量
3、通过指针访问结构体变量的数据
### <font color = pink>嵌套结构体</font>
结构体中的成员也是一个结构体
### <font color = pink>结构体作函数参数</font>
1、值传递
2、地址传递（效率更高）
### <font color = pink>结构体与const</font>
const是限定只读状态。
### <font color = pink>指针拷贝结构体</font>
指针可以少一分拷贝，节约内存（大大的节约，复制一个结构相当费内存）。
<!--2025.1.9 第一版 jz hpc-->
# <font color = skyblue>CPP核心编程</font>
### <font color = pink>内存四区</font>
意义：赋予不同的生命周期，提高编程灵活性。
```
1、代码区：存放函数体的二进制代码，由操作系统管理的
2、全局区；存放全局变量和静态变量以及常量
3、栈区：由编译器自动分配释放，存放函数的参数值，局部变量等
4、堆区：由程序员分配和释放，若程序员不释放，程序结束的时候由操作系统回收
```
* 程序运行前就有的：
代码区：
存放CPU执行的机器指令。
共享性，对于多次频繁被执行的程序，只需要在内存中有一份即可。
只读性，防止程序意外修改了它的指令。
全局区：
全局变量（global）、静态变量（static）、常量	1）字符串常量	2）const修饰的变量	(a) const修饰的全局变量	(b) const修饰的局部变量。该区域的数据在程序结束后由操作系统释放。
* 程序运行后才有的：
栈区 stack
堆区 heap
### <font color = pink>动态内存申请与释放</font>
new delete
### <font color = pink>引用</font>
给内存重新取一个名字
```cpp
数据类型 &别名 = 原名;
```
1、必须要初始化
2、初始化后不可以更改
### <font color = pink>值传递	地址传递	引用传递</font>

引用作为函数的返回值
1、不要返回局部变量的引用
2、函数的调用可以作为左值
```cpp
int& out()
{
    static int a = 10;  // 不要返回局部变量的引用
    return a;
}
	int& s = out();     //函数的调用可以作为左值
    out() = 100;
    cout<< s <<endl;
```
引用本质是一个指针常量（引用：自动挡；指针：手动挡）
```cpp
int& ref = a;
等价于
int* const ref = &a;
```
常量引用
```cpp
const int& ref = 10;
```
### <font color = pink>函数提高</font>
1、函数的默认参数
2、函数的占位参数

3、函数重载
* 函数名可以相同，提高复用性，同一作用域下，函数名称相同，函数参数类型不同，或者个数不同，或者顺序不同，都可以作为函数重载的标志。
### <font color = pink>类和对象（封装继承多态）</font>
CPP认为万物皆为对象，对象上有其属性和行为。
### <font color = pink>封装</font>
1、将属性和行为作为一个整体，表现生活中的事物。2、将属性和行为加以权限控制。
封装意义：在设计类的时候，属性和行为写在一起，表现事物。

封装语法：
```cpp
class 类名
{
访问权限:
    属性;
    行为;
};
```
实例化：通过一个类创建一个对象的过程。类：例如人类，是一种抽象出来的概念；对象：是具体化后的一个人，有特有的名字，年龄等。
类中的属性和行为，统一称为成员。属性，又名：成员属性、成员变量。行为，又名：成员函数、成员方法。
### <font color = pink>访问权限（public、protected、private）</font>
1、公共权限 public 成员，类内外皆可访问。2、保护权限 protected 成员，类内可以访问，类外不可访问。3、私有权限 private 成员，类内可以访问，类外不可访问。
保护和私有权限的区别在于继承，保护权限成员可以被子类继承，私有权限无法被继承。例如父亲的银行卡密码不想被儿子继承，那就银行卡密码设置为私有属性即可。
### <font color = pink>struct 和 class</font>
结构的默认权限是公有，类的默认权限是私有；其余没有区别。
### <font color = pink>私有化成员属性（通过预留的公有接口访问）</font>
优点：1、将所有成员属性设为私有，可以自己控制读写权限。2、对于写权限，可以检查数据的有效性。
### <font color = pink>对象的初始化和清理（构造与析构）</font>
构造函数：主要作用在于创建对象时为对象的成员属性赋值，构造函数由编译器自动调用，无须手动调用。
析构函数：主要作用在于对象销毁前系统自动调用，执行一些清理工作。

构造与析构是非常重要的安全问题；不初始化，对其使用后果未知；不清理，可能造成内存泄漏等问题。如果我们不提供构造与析构函数，编译器会自己提供两个空实现作为构造析构函数。

语法：
```cpp
/*构造函数*/
类名(){}// 1、没有返回值，也不写void 2、函数名与类名相同 3、可以有参数，允许重载 4、程序生成对象时自动调用构造，无须手动调用，且只会调用一次。

/*析构函数*/
~类名(){}// 1、没有返回值，也不写void 2、函数名是波浪加类名 3、不可有参数，不许重载 4、程序在对象销毁前自动调用析构，无须手动调用，且只会调用一次。
```
### <font color = pink>构造函数的分类及调用</font>
按参数分：无参构造、有参构造。按类型分：普通构造、拷贝构造。
```cpp
/*无参构造*/
类名(){}
/*有参构造*/
类名(int a){}
/*拷贝构造*/
类名(const 类名& c) // 将传入对象的所有属性复制到新对象（克隆人）
```
调用：1、括号法  
```cpp
类名 c1;
类名 c2(10);
类名 c3(c2);
error：类名 f();    // 这个东西会被编译器误认为函数声明
```
2、显式法
```cpp
类名 c1;
类名 c2 = 类名(10); // 右侧为匿名对象，当前行执行结束后，匿名对象立即销毁
类名 c3 = 类名(c2);
error：类名(c3)     // 不要用拷贝构造函数初始化匿名对象。会重定义错误，命名重复。
```
3、隐式转换法
```cpp
类名 c1 = 10;       // 等价于：类名 c1 = 类名(10);
类名 c2 = c1;       // 等价于：类名 c2 = 类名(c1);
```
### <font color = pink>拷贝构造调用时机</font>
1、使用一个已经创建完毕的对象来初始化一个新对象。
```cpp

```
2、值传递的方式给函数参数传值。
```cpp

```
3、以值的方式返回局部对象。
```cpp

```